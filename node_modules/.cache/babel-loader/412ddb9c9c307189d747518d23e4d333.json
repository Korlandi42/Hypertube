{"ast":null,"code":"import _toConsumableArray from \"/Users/korlandi/42/hypertube/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/korlandi/42/hypertube/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/korlandi/42/hypertube/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/korlandi/42/hypertube/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/korlandi/42/hypertube/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/korlandi/42/hypertube/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport React from 'react';\nimport { bindActionCreators } from 'redux';\nimport { connect } from 'react-redux';\nimport { withSnackbar } from 'notistack';\nimport { removeSnackbar } from '../redux/snackbars/actions';\n\nvar Notifier =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Notifier, _React$Component);\n\n  function Notifier() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Notifier);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Notifier)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.displayed = [];\n\n    _this.storeDisplayed = function (id) {\n      _this.displayed = [].concat(_toConsumableArray(_this.displayed), [id]);\n    };\n\n    return _this;\n  }\n\n  _createClass(Notifier, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(_ref) {\n      var _ref$notifications = _ref.notifications,\n          newSnacks = _ref$notifications === void 0 ? [] : _ref$notifications;\n      var currentSnacks = this.props.notifications;\n      var notExists = false;\n\n      var _loop = function _loop(i) {\n        if (notExists) return \"continue\";\n        notExists = notExists || !currentSnacks.filter(function (_ref2) {\n          var key = _ref2.key;\n          return newSnacks[i].key === key;\n        }).length;\n      };\n\n      for (var i = 0; i < newSnacks.length; i += 1) {\n        var _ret = _loop(i);\n\n        if (_ret === \"continue\") continue;\n      }\n\n      return notExists;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this2 = this;\n\n      var _this$props$notificat = this.props.notifications,\n          notifications = _this$props$notificat === void 0 ? [] : _this$props$notificat;\n      notifications.forEach(function (notification) {\n        // Do nothing if snackbar is already displayed\n        if (_this2.displayed.includes(notification.key)) return; // Display snackbar using notistack\n\n        _this2.props.enqueueSnackbar(notification.message, notification.options); // Keep track of snackbars that we've displayed\n\n\n        _this2.storeDisplayed(notification.key); // Dispatch action to remove snackbar from redux store\n\n\n        _this2.props.removeSnackbar(notification.key);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return Notifier;\n}(React.Component);\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    notifications: state.snackbars.notifications\n  };\n};\n\nvar mapDispatchToProps = function mapDispatchToProps(dispatch) {\n  return bindActionCreators({\n    removeSnackbar: removeSnackbar\n  }, dispatch);\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(withSnackbar(Notifier));","map":{"version":3,"sources":["/Users/korlandi/42/hypertube/src/imported/Notifier.jsx"],"names":["React","bindActionCreators","connect","withSnackbar","removeSnackbar","Notifier","displayed","storeDisplayed","id","notifications","newSnacks","currentSnacks","props","notExists","i","filter","key","length","forEach","notification","includes","enqueueSnackbar","message","options","Component","mapStateToProps","state","snackbars","mapDispatchToProps","dispatch"],"mappings":";;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,kBAAT,QAAmC,OAAnC;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,YAAT,QAA6B,WAA7B;AACA,SAASC,cAAT,QAA+B,4BAA/B;;IAEMC,Q;;;;;;;;;;;;;;;;;UACJC,S,GAAY,E;;UAEZC,c,GAAiB,UAACC,EAAD,EAAQ;AACvB,YAAKF,SAAL,gCAAqB,MAAKA,SAA1B,IAAqCE,EAArC;AACD,K;;;;;;;gDAEwD;AAAA,oCAAjCC,aAAiC;AAAA,UAAlBC,SAAkB,mCAAN,EAAM;AAAA,UAChCC,aADgC,GACd,KAAKC,KADS,CAC/CH,aAD+C;AAEvD,UAAII,SAAS,GAAG,KAAhB;;AAFuD,iCAG9CC,CAH8C;AAIrD,YAAID,SAAJ,EAAe;AACfA,QAAAA,SAAS,GAAGA,SAAS,IAAI,CAACF,aAAa,CAACI,MAAd,CAAqB;AAAA,cAAGC,GAAH,SAAGA,GAAH;AAAA,iBAAaN,SAAS,CAACI,CAAD,CAAT,CAAaE,GAAb,KAAqBA,GAAlC;AAAA,SAArB,EAA4DC,MAAtF;AALqD;;AAGvD,WAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACO,MAA9B,EAAsCH,CAAC,IAAI,CAA3C,EAA8C;AAAA,yBAArCA,CAAqC;;AAAA,iCAC7B;AAEhB;;AACD,aAAOD,SAAP;AACD;;;yCAEoB;AAAA;;AAAA,kCACY,KAAKD,KADjB,CACXH,aADW;AAAA,UACXA,aADW,sCACK,EADL;AAGnBA,MAAAA,aAAa,CAACS,OAAd,CAAsB,UAACC,YAAD,EAAkB;AACtC;AACA,YAAI,MAAI,CAACb,SAAL,CAAec,QAAf,CAAwBD,YAAY,CAACH,GAArC,CAAJ,EAA+C,OAFT,CAGtC;;AACA,QAAA,MAAI,CAACJ,KAAL,CAAWS,eAAX,CAA2BF,YAAY,CAACG,OAAxC,EAAiDH,YAAY,CAACI,OAA9D,EAJsC,CAKtC;;;AACA,QAAA,MAAI,CAAChB,cAAL,CAAoBY,YAAY,CAACH,GAAjC,EANsC,CAOtC;;;AACA,QAAA,MAAI,CAACJ,KAAL,CAAWR,cAAX,CAA0Be,YAAY,CAACH,GAAvC;AACD,OATD;AAUD;;;6BAEQ;AACP,aAAO,IAAP;AACD;;;;EAlCoBhB,KAAK,CAACwB,S;;AAqC7B,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAAAC,KAAK;AAAA,SAAK;AAChCjB,IAAAA,aAAa,EAAEiB,KAAK,CAACC,SAAN,CAAgBlB;AADC,GAAL;AAAA,CAA7B;;AAIA,IAAMmB,kBAAkB,GAAG,SAArBA,kBAAqB,CAAAC,QAAQ;AAAA,SAAI5B,kBAAkB,CAAC;AAAEG,IAAAA,cAAc,EAAdA;AAAF,GAAD,EAAqByB,QAArB,CAAtB;AAAA,CAAnC;;AAEA,eAAe3B,OAAO,CACpBuB,eADoB,EAEpBG,kBAFoB,CAAP,CAGbzB,YAAY,CAACE,QAAD,CAHC,CAAf","sourcesContent":["import React from 'react';\nimport { bindActionCreators } from 'redux';\nimport { connect } from 'react-redux';\nimport { withSnackbar } from 'notistack';\nimport { removeSnackbar } from '../redux/snackbars/actions';\n\nclass Notifier extends React.Component {\n  displayed = [];\n\n  storeDisplayed = (id) => {\n    this.displayed = [...this.displayed, id];\n  };\n\n  shouldComponentUpdate({ notifications: newSnacks = [] }) {\n    const { notifications: currentSnacks } = this.props;\n    let notExists = false;\n    for (let i = 0; i < newSnacks.length; i += 1) {\n      if (notExists) continue;\n      notExists = notExists || !currentSnacks.filter(({ key }) => newSnacks[i].key === key).length;\n    }\n    return notExists;\n  }\n\n  componentDidUpdate() {\n    const { notifications = [] } = this.props;\n\n    notifications.forEach((notification) => {\n      // Do nothing if snackbar is already displayed\n      if (this.displayed.includes(notification.key)) return;\n      // Display snackbar using notistack\n      this.props.enqueueSnackbar(notification.message, notification.options);\n      // Keep track of snackbars that we've displayed\n      this.storeDisplayed(notification.key);\n      // Dispatch action to remove snackbar from redux store\n      this.props.removeSnackbar(notification.key);\n    });\n  }\n\n  render() {\n    return null;\n  }\n}\n\nconst mapStateToProps = state => ({\n  notifications: state.snackbars.notifications,\n});\n\nconst mapDispatchToProps = dispatch => bindActionCreators({ removeSnackbar }, dispatch);\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(withSnackbar(Notifier));\n"]},"metadata":{},"sourceType":"module"}